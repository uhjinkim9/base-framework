"use client";
import {useEffect, useState, useRef} from "react";
import {ContextMenuProvider} from "@/context/ContextMenu";
import {usePlanContext} from "@/context/PlanContext";
import {requestPost} from "@/util/api/api-service";
import {parseXmlToJson} from "@/util/helpers/parseXml";
import {isEmpty, isNotEmpty} from "@/util/validators/check-empty";
import {
  PlanVisibilityTypes,
  PublicHolidayType,
  PlanType,
  PlanTypes,
  RepeatRuleType,
  EventType,
  planTypeMap,
} from "@/types/plan.type";
import {toUTCDateString} from "@/util/helpers/timezone";
import {getContrastTextColor} from "@/util/helpers/color-helper";
import ColoredCircle from "@/components/common/segment/ColoredCircle";
import {useContextMenu} from "@/context/ContextMenu";
import useModal from "@/hooks/useModal";

import PlanAddModal from "@/components/src/plan/modal/PlanAddModal";
import PlanViewModal from "@/components/src/plan/modal/PlanViewModal";
import ContextMenuComponent from "../../common/segment/ContextMenuComponent";

import dayjs from "dayjs";
import utc from "dayjs/plugin/utc";
import isSameOrAfter from "dayjs/plugin/isSameOrAfter";
import isSameOrBefore from "dayjs/plugin/isSameOrBefore";
import customParseFormat from "dayjs/plugin/customParseFormat";
import isBetween from "dayjs/plugin/isBetween";
import FullCalendarComponent from "./FullCalendar";

dayjs.extend(customParseFormat);
dayjs.extend(utc);
dayjs.extend(isBetween);
dayjs.extend(isSameOrAfter);
dayjs.extend(isSameOrBefore);

export default function Calendar() {
  const {plans, setPlans, planMenus, checkedCalList, planDispatch} =
    usePlanContext();
  const [viewRange, setViewRange] = useState<string>("");
  const [calendarEvents, setCalendarEvents] = useState<EventType[]>([]);
  const [fullCalendarEvents, setFullCalendarEvents] = useState<any[]>([]);
  const {handleContextMenuOpen} = useContextMenu();
  const addNewPlanModal = useModal();
  const showPlanModal = useModal();
  const dateRef = useRef<string | null>(null);

  const menuItems = [
    {type: "schedule", label: "ÏùºÏ†ï"},
    {type: "task", label: "ÏóÖÎ¨¥"},
    {type: "booking", label: "ÏûêÏõê ÏòàÏïΩ"},
    {type: "dayoff", label: "Ìú¥Í∞Ä"},
  ];

  // plan Îç∞Ïù¥ÌÑ∞Î•º Ï∫òÎ¶∞Îçî Ïù¥Î≤§Ìä∏Î°ú Î≥ÄÌôò
  const transformPlanDataToEvents = (plans: any[]) => {
    const filteredPlans = plans?.filter((plan) => {
      const targetKey = String(plan?.planMenu?.menuId ?? plan?.menuIdx ?? "");
      const isChecked = checkedCalList?.some(
        (cal: any) => cal.name === targetKey,
      );
      return isChecked;
    });

    return (
      filteredPlans?.map((plan) => {
        // Í∏∞Ï°¥ plan Î≥ÄÌôò Î°úÏßÅ
        const startedAt =
          plan?.isAllday && plan?.startedAt
            ? plan.startedAt.split("T")[0]
            : plan?.startedAt || null;
        const endedAt =
          plan?.isAllday && plan?.endedAt
            ? plan.endedAt.split("T")[0]
            : plan?.endedAt || null;

        const holidayMenuId = "public-holiday";
        const menuColor = plan?.planMenu?.menuColor || "#FF6900";

        const event = {
          id:
            isEmpty(plan?.planIdx) && plan?.planMenu?.menuId === holidayMenuId
              ? `holiday-${plan?.locdate}`
              : String(plan?.planIdx ?? ""),
          title: plan?.title ?? plan?.dateName ?? "",
          start: startedAt,
          end: endedAt,
          color: menuColor,
          textColor: getContrastTextColor(menuColor),
          extendedProps: plan,
        };
        return event;
      }) || []
    );
  };

  const getPlans = async (viewRange: string) => {
    if (!viewRange) return [];
    const res = await requestPost("/plan/getPlans", {
      range: viewRange,
    });

    if (res.statusCode === 200) {
      const plans = res.data;
      const updated = plans.map((prev: any) => ({
        ...prev,
        menuIdx: String(prev.menuIdx),
        planMenu: {
          ...prev.planMenu,
          menuIdx: String(prev.planMenu.menuIdx),
        },
      }));
      return updated;
    }
    return [];
  };

  useEffect(() => {
    console.log("üìÖ [getPlans] ÏùºÏ†ï Îç∞Ïù¥ÌÑ∞ ÏÉÅÌÉú", plans);
  }, [plans]);

  // plansÎÇò checkedCalList Î≥ÄÍ≤ΩÏãú Ïù¥Î≤§Ìä∏ Î≥ÄÌôò
  useEffect(() => {
    const transformedEvents = transformPlanDataToEvents(plans || []);
    console.log("üìÖ [Calendar] Transformed Events:", transformedEvents);
    setCalendarEvents(transformedEvents);
  }, [plans, checkedCalList]);

  // calendarEvents Î≥ÄÍ≤ΩÏãú FullCalendar Ïù¥Î≤§Ìä∏Î°ú Î≥ÄÌôò
  useEffect(() => {
    const fullCalendarEvents = transformToFullCalendarEvents(calendarEvents);
    console.log("üìÖ [Calendar] FullCalendar Events:", fullCalendarEvents);
    setFullCalendarEvents(fullCalendarEvents);
  }, [calendarEvents]);

  useEffect(() => {
    if (!viewRange) return;
    if (!planMenus?.public) return; // planMenus Î°úÎìú ÎåÄÍ∏∞

    (async () => {
      const [planRes, holidayRes] = await Promise.all([
        getPlans(viewRange),
        getPublicHolidays(viewRange),
      ]);
      setPlans([...planRes, ...(holidayRes ?? [])]);
    })();
  }, [viewRange, planMenus]);

  const getPublicHolidays = async (
    viewRange: string,
  ): Promise<PublicHolidayType[]> => {
    const startDateStr = viewRange?.split("~")[0];
    const endDateStr = viewRange?.split("~")[1];

    const startDate = startDateStr ? new Date(startDateStr) : undefined;
    const endDate = endDateStr ? new Date(endDateStr) : undefined;

    if (startDate && endDate) {
      const diffMs = endDate.getTime() - startDate.getTime();
      // ms ‚Üí Ïùº(day)Î°ú Î≥ÄÌôò, +10ÏùÄ Ï†ÑÏõî Ïù∏Ïãù Î∞©ÏßÄÏö©ÏúºÎ°ú 10Ïùº ÎçîÌïú Í≤É
      const diffDays = diffMs / (1000 * 60 * 60 * 24) + 10;

      // | Íµ¨Î∂Ñ   | ÌåêÎ≥Ñ Í∏∞Ï§Ä (ÎåÄÎûµ)                       |
      // | ----- | ------------------------------------- |
      // | week  | 7Ïùº ‚âí 604,800,000ms                   |
      // | month | ÏïΩ 35\~40Ïùº ‚âí 2,678,400,000ms (6Ï£ºÏπò)  |
      // | year  | ÏïΩ 365Ïùº ‚âí 31,536,000,000ms           |

      let rangeType: "week" | "month" | "year";
      if (diffDays <= 8) {
        rangeType = "week";
      } else if (diffDays <= 45) {
        rangeType = "month";
      } else {
        rangeType = "year";
      }

      if (rangeType === "week" || rangeType === "month") {
        const year = startDate.getFullYear();
        const month = startDate.getMonth() + 1;
        const res = await requestPost("/plan/getPublicHolidays", {year, month});
        if (!res) return [];

        const parsed = parseXmlToJson(res);
        const items = parsed?.response?.body?.items?.item;

        return transformPublicHolidays(items);
      } else if (rangeType === "year") {
        // Ïó∞ÎèÑ Î∑∞ÏóêÏÑúÎäî Í≥µÌú¥Ïùº ÌëúÏãúÌïòÏßÄ ÏïäÏùå (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
        // ÌïÑÏöîÏãú Ïõî Îã®ÏúÑÎ°ú Ï∫òÎ¶∞ÎçîÎ•º Ïù¥ÎèôÌïòÎ©¥ÏÑú ÌôïÏù∏ Í∞ÄÎä•
        console.log(
          "üìÖ [getPublicHolidays] Ïó∞ÎèÑ Î∑∞ÏóêÏÑúÎäî Í≥µÌú¥ÏùºÏùÑ ÌëúÏãúÌïòÏßÄ ÏïäÏäµÎãàÎã§.",
        );
        return [];
      }
    }
    return [];
  };

  const transformPublicHolidays = (rawItems: any[]): PublicHolidayType[] => {
    if (isEmpty(rawItems)) return [];

    const holidayMenuId = "public-holiday";
    const holidayMenuIdx = planMenus?.public?.find(
      (cal) => cal.menuId === holidayMenuId,
    )?.menuIdx;

    return rawItems.map((item) => ({
      planType: "holiday" as const,
      menuIdx: holidayMenuIdx,
      planMenu: {
        menuIdx: holidayMenuIdx,
        menuId: holidayMenuId,
        menuColor: item?.isHoliday === "Y" ? "#D30000" : "#129635",
      },
      title: item?.dateName,
      startedAt: dayjs
        .utc(String(item?.locdate), "YYYYMMDD")
        .format("YYYY-MM-DDT00:00:00"),
      endedAt: dayjs
        .utc(String(item?.locdate), "YYYYMMDD")
        .format("YYYY-MM-DDT23:59:59"),
      visibility: PlanVisibilityTypes.PRIVATE,
      isAllday: true,
      ...item,
    }));
  };

  // EventTypeÏùÑ FullCalendar Ïù¥Î≤§Ìä∏Î°ú Î≥ÄÌôò
  const transformToFullCalendarEvents = (events: EventType[]) => {
    return events.map((event) => {
      const eventData = event.extendedProps;
      const isRepeated = eventData?.isRepeated && eventData?.repeatRule;
      const isTask = eventData?.planType === "task";

      const baseEvent = {
        id: event.id !== undefined ? String(event.id) : undefined,
        color: event.color,
        title: event.title,
        textColor: event.textColor,
        extendedProps: eventData,
        durationEditable: !isTask, // Î¶¨ÏÇ¨Ïù¥Ï¶à Î∂àÍ∞Ä ÏÑ§Ï†ï
      };

      if (isRepeated) {
        const rule = eventData.repeatRule;

        return {
          ...baseEvent,
          rrule: {
            freq: rule.freq,
            interval: rule.interval,
            count: rule.repeatEndType === "count" ? rule.count : undefined,
            until:
              rule.repeatEndType === "until" && rule.until
                ? dayjs(rule.until).toISOString()
                : undefined,
            dtstart: eventData.startedAt,
          },
          duration: eventData.isAllday
            ? {days: 1} // ÌïµÏã¨! Ï¢ÖÏùº Î∞òÎ≥µ Ïù¥Î≤§Ìä∏Îäî durationÏùÑ daysÎ°ú!
            : new Date(eventData.endedAt).getTime() -
              new Date(eventData.startedAt).getTime(),
          allDay: eventData.isAllday,
        };
      } else {
        return {
          ...baseEvent,
          start: eventData?.startedAt,
          end: eventData?.endedAt,
          allDay: eventData?.isAllday,
        };
      }
    });
  };

  // plan Ï†ÑÏö© eventContent Î†åÎçîÎü¨
  const renderEventContent = (arg: any) => {
    const eventData = arg.event.extendedProps;
    const plan = eventData;
    const planType = plan?.planType as PlanTypes;
    const menuColor = plan?.planMenu?.menuColor;
    const menuNm = plan?.planMenu?.menuNm;

    const typeKor = planTypeMap[planType];

    return (
      <div className="fc-event-custom-content">
        {!plan.isAllday && <ColoredCircle colorCode={menuColor ?? "#000"} />}
        <b>
          [{menuNm ? `${menuNm}/` : ""}
          {typeKor}]
        </b>
        <div>{arg.event.title}</div>
      </div>
    );
  };

  // Ïª¥ÌÖçÏä§Ìä∏Î©îÎâ¥ Ìï∏Îì§Îü¨
  const handleClickContextMenu = (type: string) => {
    planDispatch({
      type: "RESET",
      payload: {
        startedAt: dateRef.current,
        endedAt: dateRef.current
          ? dayjs(dateRef.current).add(1, "hour").toISOString()
          : dateRef.current,
      },
    });
    planDispatch({
      type: "UPDATE_PLAN_FIELD",
      payload: {
        name: "planType",
        value: type as PlanTypes,
      },
    });
    addNewPlanModal.openModal();
  };

  // Ïª¥ÌÖçÏä§Ìä∏Î©îÎâ¥ Ïò§Ìîà Ìï∏Îì§Îü¨
  const handleContextMenu = (e: MouseEvent, dateRefValue: string | null) => {
    dateRef.current = dateRefValue;
    // @ts-expect-error: Accept native MouseEvent for context menu
    handleContextMenuOpen(e);
  };

  // Ïù¥Î≤§Ìä∏ ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
  const handleEventClick = (info: any) => {
    const eventData = info.event.extendedProps;

    if (eventData && eventData.planIdx) {
      planDispatch({type: "RESET"});
      planDispatch({
        type: "SET_SELECTED",
        payload: eventData.planIdx,
      });
      showPlanModal.openModal();
    }
  };

  // Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ® Ìï®Ïàò
  const refreshPlanData = async () => {
    if (viewRange && planMenus?.public) {
      const [planRes, holidayRes] = await Promise.all([
        getPlans(viewRange),
        getPublicHolidays(viewRange),
      ]);
      setPlans([...planRes, ...(holidayRes ?? [])]);
    }
  };

  // plan Ïù¥Îèô Ï≤òÎ¶¨ Ìï®ÏàòÎì§
  async function onMovePlan(
    planIdx: number,
    planType: string,
    startedAt: string,
    endedAt: string,
    repeatRule: RepeatRuleType,
  ) {
    const plan = {
      planIdx,
      planType: planType as PlanTypes,
      startedAt,
      endedAt,
    };
    await onSubmitPlan(plan, repeatRule);
  }

  async function onSubmitPlan(plan: PlanType, repeatRule: RepeatRuleType) {
    const payload: any = {
      plan,
      planType: plan.planType,
    };

    if (isNotEmpty(repeatRule)) {
      payload.repeatRule = repeatRule;
    }

    const res = await requestPost("/plan/createOrUpdatePlan", payload);
    if (res.statusCode === 200) {
      await refreshPlanData();
    } else {
      alert("Ïù¥Îèô„Ñ¥„Ñ¥");
    }
  }

  // Ïù¥Î≤§Ìä∏ ÎìúÎ°≠ Ìï∏Îì§Îü¨
  const handleEventDrop = (info: any) => {
    const {planIdx, planType, isRepeated, rrule} = info.event.extendedProps;
    const {start, end} = info.event;
    const repeatRule = isRepeated ? rrule : null;

    if (!start || !end) {
      alert("Ïù¥Îèô ÏùºÏûê ÏÑ†ÌÉùÏóê Ïò§Î•òÍ∞Ä ÏûàÏäµÎãàÎã§.");
      return;
    }

    onMovePlan(
      planIdx,
      planType,
      toUTCDateString(start.toISOString()),
      toUTCDateString(end.toISOString()),
      repeatRule,
    );
  };

  // Ïù¥Î≤§Ìä∏ Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§Îü¨
  const handleEventResize = (info: any) => {
    const {planIdx, planType, isRepeated, rrule} = info.event.extendedProps;
    const {start, end} = info.event;
    const repeatRule = isRepeated ? rrule : null;

    if (!start || !end) {
      alert("Ïù¥Îèô ÏùºÏûê ÏÑ†ÌÉùÏóê Ïò§Î•òÍ∞Ä ÏûàÏäµÎãàÎã§.");
      return;
    }

    onMovePlan(
      planIdx,
      planType,
      toUTCDateString(start.toISOString()),
      toUTCDateString(end.toISOString()),
      repeatRule,
    );
  };

  // ÎÇ†Ïßú ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
  const handleDateClick = (info: any) => {
    console.log("ÎÇ†Ïßú ÌÅ¥Î¶≠:", info.dateStr);
    // ÌïÑÏöîÏãú plan ÏÉùÏÑ± Î™®Îã¨ Ïó¥Í∏∞ Îì±Ïùò Î°úÏßÅ Ï∂îÍ∞Ä Í∞ÄÎä•
  };

  return (
    <>
      <ContextMenuProvider>
        <FullCalendarComponent
          events={fullCalendarEvents}
          setViewRange={setViewRange}
          onEventClick={handleEventClick}
          onEventDrop={handleEventDrop}
          onEventResize={handleEventResize}
          onDateClick={handleDateClick}
          onContextMenu={handleContextMenu}
          eventContent={renderEventContent}
        />
        <PlanAddModal addNewPlanModal={addNewPlanModal} />
        <PlanViewModal showPlanModal={showPlanModal} />
        <ContextMenuComponent
          handleClickContextMenu={handleClickContextMenu}
          menuItems={menuItems}
        />
      </ContextMenuProvider>
    </>
  );
}
